---
title: "PLATCOV Statistical Analysis"
author: "James Watson"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: yes
    fig_caption: yes
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE, cache.comments = FALSE,
                      echo = F, include = TRUE, 
                      fig.width = 8, fig.height = 8,
                      fig.pos = 'H',dev = 'png', dpi = 300)

library(rstan)
library(lme4)
library(rstanarm)
library(loo)
library(RColorBrewer)
library(censReg)
library(tictoc)
library(reshape2)
```

TODO list:

* Check missing data (vaccine/serology/age)
* Subgroup analysis model for variants


## Preambule

This Statistical Analysis Plan (SAP) is written for the PLATCOV trial (registered at ClinicalTrials.gov: https://clinicaltrials.gov/ct2/show/NCT05041907).

Data preparation is done in a different R script called data_prep.R.
This Markdown script assumes that the data are saved in two .csv files in long format. 

The first file *interim_control_dat.csv* contains the PCR quality control data: CT values from the control samples from each plate (duplicate control samples of known viral densities over the range 100 to 10^7/mL viral copies per mL). This has the following headers:

- ID: unique control ID
- Plate: unique PCR Plate ID
- CT_NS: observed CT value for the N/S gene
- log10_true_density: number of viral copies in control sample (log10 scale)

The second file *interim_dat.csv* contains the patient viral load data with the following column headers:

- ID: anonymised patient id code
- BARCODE: unique sample id code (in the following format: PLT-site-number-swab type-timepoint)
- Timepoint_ID: Day of study (0 to 14)
- Swab_ID: RTS or TSL (right versus left tonsil)
- Plate: unique Plate ID for the PCR assay (matching with plate identifiers in interim_control_dat.csv)
- Site: site at enrollment
- Trt: treatment allocation as written in CRF
- Time: time from randomisation
- Variant: variant of concern (using standard WHO terminology for the main lineages, reference will be the predominant variant in the dataset at the start of the study)
- Any_dose: (0/1) any doses of any manufacturer received
- N_dose: integer number of doses received (any manufacturer)
- Antibody_test: 0/1 (negative/positive for SARS-CoV-2 antibody rapid test)
- Age: (years - has to be between 18-50)
- Sex: 0/1 (male: 1; female/other: 0)
- BMI: kg/weight^2
- Symptom_onset: time since onset of symptoms (days)
- CT_NS: observed CT value for the N/S gene
- CT_RNaseP: observed CT value for the human RNase P gene
- log10_viral_load: log10 number of viral copies per mL (estimated from plate specific standard curve - 12 controls per plate)


## Computational setup

```{r}
## information on software/hardware used
version
sessionInfo()
```

## Load data

```{r}
# source('data_prep.R')
rstan_options(auto_write = TRUE)
## parameters for the analysis
Dmax = 8
RUN_MODELS = F
```


## Data summaries

```{r data_summaries}
platcov_dat = read.csv('interim_dat.csv')
control_dat = read.csv('interim_control_dat.csv')

IDs = unique(platcov_dat$ID)

writeLines(sprintf('We have %s PCR datapoints on %s patients from %s sites',
                   length(unique(platcov_dat$BARCODE)),
                   length(IDs),
                   length(unique(platcov_dat$Site))))

ind_dup = !duplicated(platcov_dat$ID)

platcov_dat$Rand_date = as.POSIXct(platcov_dat$Rand_date)

my_breaks = c(as.POSIXct(c('2021-09-01','2022-01-01')),
              as.POSIXct(format(Sys.time(),
                                '%Y-%m-%d %H:%M:%OS')))

platcov_dat$Epoch = cut(platcov_dat$Rand_date, breaks = my_breaks)
table(platcov_dat$Epoch[ind_dup])
table(platcov_dat$Trt[ind_dup], platcov_dat$Epoch[ind_dup])
platcov_dat$Epoch = as.numeric(as.factor(as.character(platcov_dat$Epoch)))

par(las=1, cex.lab=1.5, cex.axis=1.5, family='serif')
plot(platcov_dat$Rand_date[ind_dup], 1:length(IDs),
     col=platcov_dat$Epoch[ind_dup],
     xlab='Enrollment date', ylab='Patient ID',panel.first=grid())

table(Arm=platcov_dat$Trt[ind_dup], Site = platcov_dat$Site[ind_dup])

platcov_dat$Trt_number = as.numeric(as.factor(platcov_dat$Trt))

writeLines('Age distribution of patients:')
print(aggregate(Age ~ Site, platcov_dat[ind_dup, ], 
                function(x) c(mean = round(mean(x)), min = min(x), max = max(x))))

writeLines('Proportion male (%):')
print(aggregate(Sex ~ Site, platcov_dat[ind_dup, ], function(x) round(100*mean(x))))

writeLines('Proportion vaccinated (%):')
print(aggregate(Any_dose ~ Site, platcov_dat[ind_dup, ], function(x) round(100*mean(x))))

writeLines('Number of vaccine doses by site:')
table(Site=platcov_dat$Site[ind_dup], platcov_dat$N_dose[ind_dup])

writeLines('Number of days since symptom onset by site:')
table(Site=platcov_dat$Site[ind_dup], 
      Sympom_Onset_days = platcov_dat$Symptom_onset[ind_dup])

# baseline samples: taken within 6 hours of randomisation
baseline_ind = platcov_dat$Timepoint_ID==0

bvl = aggregate(log10_viral_load ~ ID, platcov_dat[baseline_ind, ], median)
nrow(bvl) == length(IDs)

writeLines(sprintf('In the %s patients, the geometric mean baseline (defined as samples taken within 6 hours of randomisation) viral load was %s copies per mL (95 percentile interval from %s to %s; range from %s to %s)',
                   length(IDs),
                   round(10^mean(bvl$log10_viral_load)),
                   round(10^(mean(bvl$log10_viral_load)-1.96*sd(bvl$log10_viral_load))),
                   round(10^(mean(bvl$log10_viral_load)+1.96*sd(bvl$log10_viral_load))),
                   round(min(10^bvl$log10_viral_load)),
                   round(max(10^bvl$log10_viral_load))))
hist(bvl$log10_viral_load,
     breaks = seq(1.5,8.5,by=.5),
     xlab='Baseline viral load (copies per mL)',
     ylab ='Number of patients',xlim=c(2,8),
     main='', xaxt ='n')
axis(1, at = c(2,4,6,8), labels = c(expression(10^2),
                                    expression(10^4),
                                    expression(10^6),
                                    expression(10^8)))
```

## Data visualisation

### Quality Control for PCR

```{r PCR_QC}
par(las=1, mfrow=c(2,2), cex.lab=1.5, cex.axis=1.5,family='serif')
plot(control_dat$log10_true_density,control_dat$CT_NS, 
     ylab='CT value', 
     xlab='Control viral density (log10 copies/mL)',
     panel.first=grid(),
     col=as.numeric(as.factor(control_dat$Plate)), ylim=c(40,18))
my_slope_coefs = array(dim = c(length(unique(control_dat$Plate)),2))

for(ss in unique(control_dat$Plate)){
  plate_ind = control_dat$Plate==ss
  mod = lm(CT_NS~log10_true_density, control_dat[plate_ind, ])
  abline(mod,col = control_dat$Plate[plate_ind])
  my_slope_coefs[which(ss==unique(control_dat$Plate)),]=coef(mod)
}

hist(my_slope_coefs[,1], xlab='Intercept', main='')
writeLines(sprintf('SD of the intercept is %s',round(sd(my_slope_coefs[,1]),2)))

hist(my_slope_coefs[,2], xlab='Slope', main='')
writeLines(sprintf('Maximum difference in CT values for a tenfold change in viral load is %s',round(diff(range(my_slope_coefs[,2])),2)))

xx = aggregate(CT_NS ~ Plate + log10_true_density, 
               data = control_dat, 
               function(x) c(mean(x), diff(x)))
par(las=1)
plot(xx$CT[,1], xx$CT[,2], 
     xlab = 'Mean CT',
     ylab = 'CT Difference from duplicates',
     panel.first=grid())
abline(h = 0)

xx$Mean_CT = cut(xx$CT[,1],breaks = seq(20, 40, by=5),include.lowest = T)
xx$Diff_CT = xx$CT[,2]

par(mfrow=c(1,1))
yy = aggregate(Diff_CT ~ Mean_CT, xx, sd)
plot(yy$Mean_CT, sqrt(2) * yy$Diff_CT, xlab='CT interval',
     ylab = 'Estimated measurement error (standard deviation)')
```



### Overall data

```{r trt_data_plot}
par(las=1, cex.lab=1.5, cex.axis=1.5,family='serif')
## Color by randomised treatment
# make treatment colors and indices
PCR_dat = aggregate(CT_NS ~ ID + Timepoint_ID + Trt + Site + Trt_number, 
                    data = platcov_dat,
                    FUN = function(x) c(mean=mean(x), 
                                        diff=max(x)-min(x),
                                        n = length(x)))
trt_cols = brewer.pal(n = length(unique(PCR_dat$Trt)),name = 'Dark2')
trt_smmry = aggregate(formula = CT_NS ~ Timepoint_ID+Trt_number, 
                      data = platcov_dat,
                      FUN = median)

plot(PCR_dat$Timepoint_ID, PCR_dat$CT_NS[,'mean'],  ylab='CT',
     xlab = 'Time since randomisation (days)',panel.first=grid(),
     xlim = c(0,7), type='n',
     col = trt_cols[PCR_dat$Trt_number],
     ylim = c(40, min(PCR_dat$CT_NS[,'mean'])))
for(id in IDs){
  ind = PCR_dat$ID==id
  lines(PCR_dat$Timepoint_ID[ind], PCR_dat$CT_NS[ind,'mean'],
        col=adjustcolor(trt_cols[PCR_dat$Trt_number[ind]],.3))
}
points(trt_smmry$Timepoint_ID, trt_smmry$CT_NS,
       col= trt_cols[trt_smmry$Trt_number],
       pch = 14+trt_smmry$Trt_number, cex=1.5)
for(tt in unique(trt_smmry$Trt_number)){
  ind = trt_smmry$Trt_number==tt
  lines(trt_smmry$Timepoint_ID[ind], trt_smmry$CT_NS[ind], 
        col = trt_cols[tt],lwd=3)
}
legend('topright', col=trt_cols, 
       legend = unique(PCR_dat$Trt),title = 'Median',
       lwd=2,pch=14+unique(PCR_dat$Trt_number),
       cex=1.2, inset = 0.03)
```

### Conversion to copies per mL

We fit a mixed effects model to the control data to estimate standard curves for each qPCR plate. Random slopes and random intercepts.


```{r convert_per_ml}
control_dat = dplyr::arrange(control_dat, CT_NS, Plate)
control_dat$CT = control_dat$CT_NS
control_dat$CT[control_dat$CT_NS==40]=NA
control_dat$batch = as.factor(control_dat$Plate)

if(RUN_MODELS){
  options(mc.cores = 4)
  conv_mod = stan_lmer(log10_true_density ~ 1+CT + (1+CT|batch), 
                       data = control_dat,iter = 10000)
  save(conv_mod, file = 'Rout/standard_curve_mod.RData')
} else {
  load(file = 'Rout/standard_curve_mod.RData')
}
# summary(conv_mod)
preds = colMeans(posterior_predict(conv_mod))
plot(control_dat$CT, control_dat$log10_true_density, xlim=c(20,40))
for(bb in levels(control_dat$batch)){
  ind = control_dat$batch==bb
  lines(control_dat$CT[ind], preds[ind])
}

preds_all = posterior_predict(conv_mod, 
                              newdata = data.frame(CT=platcov_dat$CT_NS,
                                                   batch=as.factor(platcov_dat$Plate)))
preds_cens = posterior_predict(conv_mod, 
                               newdata = data.frame(CT=rep(40,nrow(platcov_dat)),
                                                    batch=as.factor(platcov_dat$Plate)))
platcov_dat$log10_viral_load_pred = colMeans(preds_all)
platcov_dat$log10_cens_vl = colMeans(preds_cens)

platcov_dat$log10_viral_load_pred[platcov_dat$CT_NS==40]=platcov_dat$log10_cens_vl[platcov_dat$CT_NS==40]
table(platcov_dat$CT_NS==40)
table(platcov_dat$log10_viral_load_pred == platcov_dat$log10_cens_vl)

plot(platcov_dat$log10_viral_load, 
     platcov_dat$log10_viral_load_pred,
     col=platcov_dat$Plate)

## re-arrange so that censored values come last
platcov_dat = dplyr::arrange(platcov_dat, log10_viral_load_pred==log10_cens_vl)
```


### Human RNaseP

```{r RNaseP}
par(las=1, cex.lab=1.5, cex.axis=1.5,family='serif')
hist(platcov_dat$CT_RNaseP, main='',
     xlab='RNaseP CT',ylab='',yaxt='n', breaks = 30)
abline(v = mean(platcov_dat$CT_RNaseP) + c(1.96,-1.96)*sd(platcov_dat$CT_RNaseP),
       lwd=3, lty=2)
writeLines(sprintf('the standard deviation of the RNaseP CT distribution is %s.', 
                   round(sd(platcov_dat$CT_RNaseP),2)))

writeLines(sprintf('95%% of the distribution is within %s CT values difference',
                   round(diff(mean(platcov_dat$CT_RNaseP) + c(-1.96,1.96)*sd(platcov_dat$CT_RNaseP)),2)))
```


## Model fitting

```{r}
bayes_R2 = function(mod_preds, mod_residuals) {
  var_pred = apply(mod_preds, 1, var)
  var_res = apply(mod_residuals, 1, var)
  var_pred / (var_pred + var_res)
}
```


### Specify priors

```{r priors}
prior_params = list(alpha_0_prior_mean = 6,
                    alpha_0_prior_sd = 2,
                    beta_0_prior_mean = -.5,
                    beta_0_prior_sd = 1,
                    sigma_trt_effect = .5)
print(prior_params)
```


### Prepare model

Make stan data set.

Covariates that we use in model 2:

* Vaccination (number of doses)
* Age (standardised to have mean=0 and sd=1)
* Time since symptom onset (days, between 0 and 4)
* Variant (WHO variants of concern) - when available (this is replaced by epoch until we have variant data)
* Serology rapid test (+/-)
* Serum antibody: not yet decided which antibody will be measured - expected May/June 2022


```{r}
# ind_subgroup = platcov_dat$Trt %in% c('No study drug','Regeneron')
# platcov_dat = platcov_dat[ind_subgroup, ]
trts = c("Regeneron",
         "Ivermectin",
         "Remdesivir",
         "Favipiravir")
platcov_dat$Trt_code = 
  factor(platcov_dat$Trt,
         levels=c("No study drug", trts))

ind_fitting = platcov_dat$Time < Dmax
writeLines(sprintf('Total number of datapoints up until day %s is %s',Dmax, sum(ind_fitting)))

platcov_dat$RnaseP_scaled = t(scale(40 - platcov_dat$CT_RNaseP, 
                                    scale = F))[1,] 
platcov_dat$Age_scaled = (platcov_dat$Age-mean(platcov_dat$Age[ind_dup]))/sd(platcov_dat$Age[ind_dup])
platcov_dat_fit = platcov_dat[ind_fitting, ]

# make the covariate matrix
platcov_dat_fit$Symptom_onset[is.na(platcov_dat_fit$Symptom_onset)]=1
X_matrix = model.matrix( ~ Epoch + Age_scaled + Antibody_test + Symptom_onset, 
                         data = platcov_dat_fit)[, -1]


Trt_matrix = model.matrix( ~ Trt_code, data = platcov_dat_fit)
Trt_matrix[,1]=0
Trt_matrix_subgroup = cbind(Trt_matrix, 
                            as.numeric(platcov_dat_fit$Epoch==2 &
                                         platcov_dat_fit$Trt=='Regeneron'))

ID_map = data.frame(ID_key = platcov_dat_fit$ID,
                    ID_stan = as.numeric(as.factor(platcov_dat_fit$ID)))

ind_cens = !platcov_dat_fit$log10_viral_load_pred>platcov_dat_fit$log10_cens_vl
table(ind_cens)
analysis_data_stan = list(Ntot = nrow(platcov_dat_fit),
                          N_obs = sum(!ind_cens),
                          n_id = max(ID_map$ID_stan),
                          id = ID_map$ID_stan,
                          ind_start = which(!duplicated(ID_map$ID_stan)),
                          obs_day = platcov_dat_fit$Time,
                          log_10_vl = platcov_dat_fit$log10_viral_load_pred,
                          log10_cens_vl = platcov_dat_fit$log10_cens_vl,
                          K_trt = length(unique(platcov_dat_fit$Trt)),
                          trt_mat = Trt_matrix,
                          RNaseP = platcov_dat_fit$RnaseP_scaled,
                          K_cov = ncol(X_matrix),
                          x = X_matrix)

writeLines('check stan data formatting:')
all(analysis_data_stan$log_10_vl[1:analysis_data_stan$N_obs]>
      analysis_data_stan$log10_cens_vl[1:analysis_data_stan$N_obs]) &
  all(analysis_data_stan$log_10_vl[(1+analysis_data_stan$N_obs):analysis_data_stan$Ntot] ==
        analysis_data_stan$log10_cens_vl[(1+analysis_data_stan$N_obs):analysis_data_stan$Ntot])

```


### Run models

We fit a sequence of Bayesian hierarchical models.
To make sure there are no bugs in the code (all stan code is written specifically for this trial analysis), I fit the following sequence of five models of increasing complexity:

* Model 0: vanilla student-t regression with left censoring at 0 and with individual random effects for slope and intercept;
* Model 1: add the RNaseP measurements;
* Model 2: Add covariate adjustment;
* Model 3: Non-linear model (up and then down) with RNaseP adjustment.

```{r run_models}
all_mods = list.files('Stan_models',full.names = TRUE,pattern = '*stan')
print(all_mods)
K_models = length(all_mods)
Niter = 4000
Nwarmup = 2000
Nthin = 10
Nchain = 4

writeLines(sprintf('We are running the %s models with %s chains and %s samples for each chain, discarding half for burn-in and thining every %s, thus giving a total of %s posterior samples per model.',
                   K_models,Nchain,Niter,Nthin, 
                   Nchain*(Niter-Nwarmup)/Nthin))

if(RUN_MODELS){
  tic()
  options(mc.cores = Nchain)
  
  out = list() 
  for(mm in 1:K_models){
    writeLines(sprintf('Doing Model %s',all_mods[mm]))
    mod = stan_model(file = all_mods[mm])# compile 
    out[[mm]] = sampling(mod, # sample posterior 
                         data=c(analysis_data_stan, prior_params), 
                         iter=Niter, chain=Nchain,
                         thin=Nthin, warmup=Nwarmup)
  }
  
  # subgroup: Regeneron interaction
  analysis_data_stan$trt_mat = Trt_matrix_subgroup
  analysis_data_stan$K_trt = ncol(Trt_matrix_subgroup)
  for(mm in (1+K_models):(2*K_models)){
    writeLines(sprintf('Doing Model %s',all_mods[mm-K_models]))
    mod = stan_model(file = all_mods[mm-K_models])# compile 
    out[[mm]] = sampling(mod, # sample posterior 
                         data=c(analysis_data_stan, prior_params), 
                         iter=Niter, chain=Nchain,
                         thin=Nthin, warmup=Nwarmup)
  }
  save(out, file = 'Rout/model_fits.RData')# save output
  writeLines('Total time to fit models:')
  toc()
} else {
  load(file = 'Rout/model_fits.RData')
}

# extract parameters
rsqds = array(dim = c(Nchain*Niter/Nthin/2, K_models))
thetas = list()
# par(las=1, mfrow=c(2,3))
for(i in 1:(2*K_models)){
  thetas[[i]] = extract(out[[i]])
  my_preds = thetas[[i]]$preds
  # my_res = my_preds
  # for(k in 1:nrow(my_res)){my_res[k,] = my_preds[k,]-analysis_data_stan$log_10_vl}
  # print(mean(bayes_R2(my_preds, my_res)))
  # rsqds[,i]=bayes_R2(my_preds, my_res)
  # hist(rsqds[,i], xlab='Bayes R^squared',main=paste('Model ',i-1))
}
```

### Model fits: summaries

```{r summary}
key_pars_0 = c('trt_effect', 'alpha_0', 'beta_0',
               'sigma_logvl', 'sigmasq_u', 't_dof')
key_pars_1 = c(key_pars_0, 'gamma_rnasep')
key_pars_2 = c(key_pars_1, 'slope_coefs', 'intercept_coefs')
key_pars_3 = c(key_pars_1, 'tmax_pop')
key_pars = list(key_pars_0, key_pars_1, key_pars_2, key_pars_3)

for(mm in 1:length(out)){
  writeLines(sprintf('\n*********************\nSummary of posterior distribution for model %s',mm))
  print(summary(out[[mm]],pars=key_pars_0)$summary[,c('mean','sd','2.5%','97.5%','n_eff','Rhat')])
}

writeLines('\n*********************\n Traceplots for posterior distribution for model 0')
traceplot(out[[1]],pars=key_pars[[1]])

writeLines('\n*********************\n Traceplots for posterior distribution for model 1')
traceplot(out[[2]],pars=key_pars[[2]])

writeLines('\n*********************\n Traceplots for posterior distribution for model 2')
traceplot(out[[3]],pars=key_pars[[3]])

writeLines('\n*********************\n Traceplots for posterior distribution for model 3')
traceplot(out[[4]],pars=key_pars[[4]])

```


### Model comparisons using loo

```{r loo}
loo_out = list()
for(mm in 1:length(out)){
  log_lik = extract_log_lik(out[[mm]], merge_chains = FALSE)
  r_eff = relative_eff(exp(log_lik))
  loo_out[[mm]] = loo(log_lik, r_eff = r_eff, cores = 2)
  print(loo_out[[mm]])
}
comp = loo_compare(loo_out)
print(comp) # can set simplify=FALSE for more detailed print output
```


## Results

### Estimated treatment effects under the 5 models

Posterior distributions over the treatment effects for the interventions. Red: no effect; blue: median inferred effect.

```{r treatment_effects}
prob_superior = trt_estimate = array(dim = c(K_models, length(trts)))
colnames(trt_estimate)= trts
colnames(prob_superior)= trts
rownames(trt_estimate) = paste('Model', 0:(K_models-1), sep = '_')
rownames(prob_superior) = paste('Model', 0:(K_models-1), sep = '_')
effect_ests = list()
for(mm in 1:K_models){
  trt_estimate[mm, ] = exp(colMeans(thetas[[mm]]$trt_effect))[-1]
  prob_superior[mm, ] = round(100*apply(exp(thetas[[mm]]$trt_effect),
                                        2,function(x) mean(x>1.125)),1)[-1]
  effect_ests[[mm]]=summary(out[[mm]],pars='trt_effect',
                            probs = c(0.025, 0.1, 0.9, 0.975))$summary[,c('mean','2.5%','10%','90%','97.5%')][-1,]
}


trt_estimate = round(trt_estimate, 2)
writeLines('\n*******************\nMean estimated treatment effects (multiplicative):')
print(trt_estimate)

writeLines('\n*******************\nProbability of super-superiority:')
print(prob_superior)
```


Overall effects

```{r treatment_effect_plot}
mod_cols = brewer.pal(n = K_models,name = 'Paired')
par(bty='n', cex.lab=1.5, cex.axis=1.5,family='serif',
    mar=c(5,7,2,2),las=1)
plot(NA, NA, xlim = range(sapply(effect_ests, rbind)), 
     ylim = c(0.5,length(trts)+.5), type='n', 
     panel.first=grid(), ylab='', yaxt='n',
     xlab = 'Effect (multiplicative on slope)', xaxt='n')
axis(1, at = log(c(0.7,1,1.5,2.4)), labels = c(0.7,1,1.5,2.4))
axis(2, at = 1:length(trts), labels = trts, tick = F)
index_p = rev(seq(-.2,.2, length.out = K_models))
abline(v=0,lwd=2)
polygon(c(-10, log(1.125), log(1.125), -10), c(-100, -100, 100, 100), border = NA, col = adjustcolor('grey',.4))
for(i in 1:K_models){
  points(effect_ests[[i]][,'mean'], 1:length(trts)+index_p[i],
         pch=16, col=mod_cols[i])
  for(j in 1:length(trts)){
    lines(c(effect_ests[[i]][j,'2.5%'], effect_ests[[i]][j,'97.5%']),
          rep(j+index_p[i],2),col=mod_cols[i],lwd=1)
    lines(c(effect_ests[[i]][j,'10%'], effect_ests[[i]][j,'90%']),
          rep(j+index_p[i],2),col=mod_cols[i],lwd=3)
  }
}
legend('topright', col=mod_cols,lwd = 2, 
       title = 'Model',
       legend = c('0 (vanilla)',
                  '1 (RNaseP)',
                  '2 (covariates)',
                  '3 (non-linear)'))
```


Treatment effect heterogeneity by presumed variant

```{r treatment_effect_plot_subgroups}
effect_ests_het = list()
for(mm in 1:K_models){
  effect_ests_het[[mm]]=summary(out[[mm+K_models]],
                                pars='trt_effect',
                                probs = c(0.025, 0.1, 0.9, 0.975))$summary[,c('mean','2.5%','10%','90%','97.5%')][-1,]
  effect_ests_het[[mm]] = rbind(effect_ests_het[[mm]][1,],
                                quantile(thetas[[mm+K_models]]$trt_effect[,2]+
                                           thetas[[mm+K_models]]$trt_effect[,6],
                                         probs=c(.5, 0.025, 0.1, 0.9, 0.975)),
                                effect_ests_het[[mm]][2:4,])
}
trts_var = c(paste(trts[1],c('\n(Delta)','\n(Omicron)')), trts[2:4])

par(bty='n', cex.lab=1.5, cex.axis=1.5,family='serif',
    mar=c(5,7,2,2),las=1)
plot(NA, NA, xlim = range(sapply(effect_ests_het, rbind)), 
     ylim = c(0.5,length(trts_var)+.5), type='n', 
     panel.first=grid(), ylab='', yaxt='n',
     xlab = 'Effect (multiplicative on slope)', xaxt='n')
axis(1, at = log(c(0.7,1,1.5,2.4)), labels = c(0.7,1,1.5,2.4))
axis(2, at = 1:length(trts_var), labels = trts_var, tick = F)
index_p = rev(seq(-.2,.2, length.out = K_models))
abline(v=0,lwd=2)
polygon(c(-10, log(1.125), log(1.125), -10), 
        c(-100, -100, 100, 100), border = NA, 
        col = adjustcolor('grey',.4))
for(i in 1:(K_models)){
  points(effect_ests_het[[i]][,'mean'], 
         1:length(trts_var)+index_p[i],
         pch=16, col=mod_cols[i])
  for(j in 1:length(trts_var)){
    lines(c(effect_ests_het[[i]][j,'2.5%'], effect_ests_het[[i]][j,'97.5%']),
          rep(j+index_p[i],2),col=mod_cols[i],lwd=1)
    lines(c(effect_ests_het[[i]][j,'10%'], effect_ests_het[[i]][j,'90%']),
          rep(j+index_p[i],2),col=mod_cols[i],lwd=3)
  }
}

legend('topright', col=mod_cols,lwd = 2, 
       title = 'Model',
       legend = c('0 (vanilla)',
                  '1 (RNaseP)',
                  '2 (covariates)',
                  '3 (non-linear)'))
```

### Estimated covariate effects

Need to make a nicer plot to show the covariate effects

```{r cov_effects,fig.height=5, fig.width=9}
par(mfrow=c(1,2),las=1,family='serif',mar=c(5,7,2,2))
alpha_coefs = apply(thetas[[7]]$intercept_coefs,2,quantile,probs=c(0.025,.1,.5,.9,0.975))
xlims=range(alpha_coefs)

plot(alpha_coefs['50%', ], 1:ncol(alpha_coefs),
     xlim=xlims,yaxt='n',ylab='',bty='n',xaxt='n',
     panel.first=grid(), xlab='Intercept (fold change)')
abline(v=0,lty=2,lwd=2)
for(i in 1:ncol(alpha_coefs)){
  lines(c(alpha_coefs['10%',i], alpha_coefs['90%',i]),
        c(i,i), lwd=3)
    lines(c(alpha_coefs['2.5%',i], alpha_coefs['97.5%',i]),
          c(i,i), lwd=1)
}
axis(2, at =1:ncol(alpha_coefs), labels = colnames(X_matrix),tick = F)
x_points = round(10^seq(xlims[1], xlims[2],length.out = 5),1)
axis(1, at = log10(x_points), labels = x_points)

beta_coefs = apply(thetas[[7]]$slope_coefs,2,quantile,probs=c(0.025,.1,.5,.9,0.975))
xlims=range(beta_coefs)
plot(beta_coefs['50%', ], 1:ncol(beta_coefs),
     xlim=xlims,yaxt='n',ylab='',bty='n',xaxt='n',
     panel.first=grid(), xlab='Slope (multiplicative effect)')
abline(v=0,lty=2,lwd=2)
for(i in 1:ncol(beta_coefs)){
  lines(c(beta_coefs['10%',i], beta_coefs['90%',i]),
        c(i,i), lwd=3)
    lines(c(beta_coefs['2.5%',i], beta_coefs['97.5%',i]),
          c(i,i), lwd=1)
}
axis(2, at =1:ncol(beta_coefs), labels = colnames(X_matrix), tick = F)
x_points = round(10^seq(xlims[1], xlims[2],length.out = 5),1)
axis(1, at = log10(x_points), labels = x_points)


```

### Slopes over time

Plot the absolute slope estimate for each individual over time

```{r slopes_over_time}
names(trt_cols)=c('No study drug', trts)
par(mfrow=c(5,1), mar = c(3,5,0.5,1),las=1,
    family='serif', cex.lab=1.3, cex.axis=1.3)
trt_allocations=platcov_dat_fit$Trt_code[analysis_data_stan$ind_start]
rand_date = platcov_dat_fit$Rand_date[analysis_data_stan$ind_start]
j=7
writeLines(sprintf('Slopes plot for model %s', all_mods[j]))
slopes = abs(extract(out[[j]])$slope)
ymax = 1.5#max(apply(slopes, 2, quantile, 0.975))
# boxplot(colMeans(slopes) ~ trt_allocations,
#         xlab='', ylab = 'Slope coefficient')
for(tt in c('No study drug', trts)){
  ind = which(trt_allocations==tt)
  plot(rand_date[ind], colMeans(slopes[,ind]),
       col=trt_cols[tt],
       xlab='', xaxt='n',
       ylim=c(0,ymax),panel.first=grid(),
       ylab='slope', xlim=range(rand_date),pch=16)
  text(x = as.POSIXct('2021-10-20'),y = 1.2,
       labels = paste0(tt,' (n=',length(ind),')'),cex=1.5)
  for(i in ind){
    lines(rep(rand_date[i],2), 
          quantile(slopes[,i],probs = c(0.025,0.975)),
          col=trt_cols[tt])
  }
  abline(v = as.POSIXct('2022-01-01'),
         h = quantile(colMeans(slopes)[trt_allocations=='No study drug'],
                      probs = .9),lty=2)
  axis(1, at = c(as.POSIXct(c('2021-10-01',
                              '2021-11-01',
                              '2021-12-01',
                              '2022-01-01',
                              '2022-02-01',
                              '2022-02-27'))), 
       labels = c('Oct','Nov','Dec','Jan','Feb','Mar'))
}
```


Plot the individual slope estimates by group

```{r slopes_by_group}
slopes = abs(extract(out[[7]])$slope)
trt_summary_dat = 
  data.frame(trt = as.character(platcov_dat_fit$Trt_code[analysis_data_stan$ind_start]),
             epoch = analysis_data_stan$x[analysis_data_stan$ind_start,1],
             slope_mean = colMeans(slopes),
             slope_upper = apply(slopes, 2, quantile, probs=0.1),
             slope_lower = apply(slopes, 2, quantile, probs=0.9),
             col = trt_cols[as.numeric(platcov_dat_fit$Trt_code[analysis_data_stan$ind_start])])
trt_summary_dat$trt[trt_summary_dat$trt=='Regeneron' &
                      trt_summary_dat$epoch==1] = 'Regeneron: Delta'
trt_summary_dat$trt[trt_summary_dat$trt=='Regeneron' &
                      trt_summary_dat$epoch==2] = 'Regeneron: Omicron'
trt_summary_dat$col[trt_summary_dat$trt=='Regeneron: Omicron']=brewer.pal(n = 8,name = 'Dark2')[8]

trt_summary_dat = dplyr::arrange(trt_summary_dat, trt, slope_mean)
par( mar = c(5,12,2,2),las=1,
     family='serif', cex.lab=1.3, cex.axis=1.3)

xlims = c(min(trt_summary_dat$slope_upper),
          max(trt_summary_dat$slope_lower))
plot(trt_summary_dat$slope_mean, 1:nrow(trt_summary_dat),
     col=trt_summary_dat$col, yaxt='n', xaxt='n',
     xlim=xlims, panel.first=grid(),
     xlab='slope', pch=16, ylab='')
ps=round(10^seq(xlims[1], xlims[2], length.out = 5),1)
axis(1, at = log10(ps),labels = ps)
abline(v = quantile(trt_summary_dat$slope_mean[trt_summary_dat$trt=='No study drug'],probs = c(0.1,0.5,0.9)), lty=c(2,1,2))

for(i in 1:nrow(trt_summary_dat)){
  lines(c(trt_summary_dat$slope_upper[i], trt_summary_dat$slope_lower[i]),
        rep(i,2),col=trt_summary_dat$col[i])
}

mid_points = array(dim = length(unique(trt_summary_dat$trt)))
kk=1
for(tt in unique(trt_summary_dat$trt)){
  mid_points[kk]=median(which(trt_summary_dat$trt==tt))
  kk=kk+1
}
axis(2, at = mid_points, labels = unique(trt_summary_dat$trt),tick = F)
```



### Individual plots

Individual plots colored by model

```{r individ_fits}
par(las=1, mfrow=c(4,4), mar=c(4,3,1,1),bty='n', 
    cex.lab=1.5, cex.axis=1.5,family='serif')
id = counter = 1
K_plots = 16
while(id <= max(ID_map$ID_stan)){
  
  # every K_plots put a legend in bottom right panel
  if(counter %% K_plots ==0){
    plot(NA,NA,xlab='',ylab='',xaxt='n',
         yaxt='n',xlim=c(0,1),ylim=c(0,1))
    legend('left', col = c(mod_cols),lwd=1,
           inset=0.03,bty='n',
           legend = c('0 (vanilla)',
                      '1 (RNaseP)',
                      '4 (covariates)',
                      '5 (non-linear)'),
           cex=1.1,title = 'Model')
  } else {
    # draw individual model fit with data
    ind = analysis_data_stan$id==id
    plot(analysis_data_stan$obs_day[ind],
         analysis_data_stan$log_10_vl[ind],xlab='',
         ylab='',panel.first=grid(),
         ylim = range(analysis_data_stan$log_10_vl))
    for(mm in 1:K_models){
      ix = order(analysis_data_stan$obs_day[ind])
      lines(analysis_data_stan$obs_day[ind][ix],
            colMeans(thetas[[mm]]$preds[,ind])[ix],
            col = mod_cols[mm])
    }
    
    mtext(text = paste(ID_map$ID_key[ID_map$ID_stan==id][1],
                       c('No study drug', trts)[analysis_data_stan$trt[ind][1]],
                       sep = ' '),
          side = 3, line = -0.2, cex=0.8)
    id=id+1
  }
  counter=counter+1
}
```


## Sensitivity analysis

### Left vs right tonsil

```{r left_versus_right}
par(las=1, bty='n', cex.lab=1.5,
    cex.axis=1.5,family='serif',mfrow=c(2,2))

dd_CT_NS = dcast(platcov_dat[,c('ID','Timepoint_ID',
                                'Swab_ID','CT_NS')],
                 ID+Timepoint_ID~Swab_ID,
                 value.var="CT_NS",
                 fun.aggregate = mean)

dd_RNaseP = dcast(platcov_dat[,c('ID','Timepoint_ID',
                                 'Swab_ID','CT_RNaseP')],
                  ID+Timepoint_ID~Swab_ID,
                  value.var="CT_RNaseP",
                  fun.aggregate = mean)

plot((dd_CT_NS$RTS+dd_CT_NS$TSL)/2, 
     dd_CT_NS$RTS-dd_CT_NS$TSL,
     xlab='Mean viral CT (left & right)', 
     ylab='Difference in viral CT (left-right)',
     panel.first=grid())
hist(dd_CT_NS$RTS-dd_CT_NS$TSL, breaks=50,main='',
     xlab='Difference in viral CT (left-right)')
plot((dd_RNaseP$RTS+dd_RNaseP$TSL)/2,
     dd_RNaseP$RTS-dd_RNaseP$TSL,
     xlab='Mean RNaseP CT (left & right)', 
     ylab='Difference in RNaseP CT (left-right)',
     panel.first=grid())
hist(dd_RNaseP$RTS-dd_RNaseP$TSL,breaks = 50,main='',
     xlab='Difference in RNaseP CT (left-right)')

par(mfrow=c(1,1))
plot(dd_RNaseP$RTS-dd_RNaseP$TSL, 
     dd_CT_NS$RTS-dd_CT_NS$TSL,
     xlab='Difference in RNaseP CT (left-right)',
     ylab='Difference in viral CT (left-right)',
     panel.first=grid())
cor_out = cor.test(dd_RNaseP$RTS-dd_RNaseP$TSL, 
                   dd_CT_NS$RTS-dd_CT_NS$TSL)
mtext(text = sprintf('Pearson correlation is %s',signif(cor_out$estimate,2)),side = 3,line = 0)
```

### Basic slope - individually fit

Use left censored linear regression

```{r non_hierarchical model}
# par(cex.lab=1.5, cex.axis=1.5,family='serif')
# 
# platcov_dat$clm_slope = NA
# platcov_dat$clm_pred = NA
# for(id in IDs){
#   ind = platcov_dat$ID==id & platcov_dat$Time<Dmax
#   if(any(platcov_dat$CT_NS[ind]==40)){
#     mod = censReg(Delta_CT ~ Time, data=platcov_dat[ind, ], left = 0)
#   } else {
#     mod = lm(Delta_CT ~ Time, data=platcov_dat[ind, ])
#   }
#   platcov_dat$clm_slope[ind] = coef(mod)['Time']
#   platcov_dat$clm_pred[ind] = coef(mod)['(Intercept)']+coef(mod)['Time']*platcov_dat$Time[ind]
# }
# 
# plot(platcov_dat$Time, platcov_dat$Delta_CT-platcov_dat$clm_pred,
#      xlim=c(0,7.5),ylab='Residual',xlab='Time')
# abline(h=0)
# 
# par(mfrow=c(1,1), mar=c(5,9,2,2),las=1, bty='n')
# ind_dup = !duplicated(platcov_dat$ID)
# bp_out=boxplot(platcov_dat$clm_slope[ind_dup] ~ platcov_dat$Trt[ind_dup],
#                ylab='',xlab='Slope',horizontal = T)
# 
# for(TT in trts){
#   writeLines(
#     sprintf(
#       'The p-value for %s is %s',
#       TT,
#       signif(t.test(platcov_dat$clm_slope[ind_dup & 
#                                             platcov_dat$Trt=='No study drug'],
#                     platcov_dat$clm_slope[ind_dup & 
#                                             platcov_dat$Trt==TT])$p.value,1)))
# }
# TT = 'Regeneron'
# writeLines(
#   sprintf(
#     'The p-value for %s versus all others is %s',
#     TT,
#     signif(t.test(platcov_dat$clm_slope[ind_dup & 
#                                           !platcov_dat$Trt==TT],
#                   platcov_dat$clm_slope[ind_dup & 
#                                           platcov_dat$Trt==TT])$p.value,1)))
```
